package handler

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i homework/internal/service.Service -o ./service_mock_test.go -n ServiceMock

import (
	"homework/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ServiceMock implements Service
type ServiceMock struct {
	t minimock.Tester

	funcCreateDevice          func(d1 model.Device) (err error)
	inspectFuncCreateDevice   func(d1 model.Device)
	afterCreateDeviceCounter  uint64
	beforeCreateDeviceCounter uint64
	CreateDeviceMock          mServiceMockCreateDevice

	funcDeleteDevice          func(s1 string) (err error)
	inspectFuncDeleteDevice   func(s1 string)
	afterDeleteDeviceCounter  uint64
	beforeDeleteDeviceCounter uint64
	DeleteDeviceMock          mServiceMockDeleteDevice

	funcGetDevice          func(s1 string) (d1 model.Device, err error)
	inspectFuncGetDevice   func(s1 string)
	afterGetDeviceCounter  uint64
	beforeGetDeviceCounter uint64
	GetDeviceMock          mServiceMockGetDevice

	funcUpdateDevice          func(d1 model.Device) (err error)
	inspectFuncUpdateDevice   func(d1 model.Device)
	afterUpdateDeviceCounter  uint64
	beforeUpdateDeviceCounter uint64
	UpdateDeviceMock          mServiceMockUpdateDevice
}

// NewServiceMock returns a mock for Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateDeviceMock = mServiceMockCreateDevice{mock: m}
	m.CreateDeviceMock.callArgs = []*ServiceMockCreateDeviceParams{}

	m.DeleteDeviceMock = mServiceMockDeleteDevice{mock: m}
	m.DeleteDeviceMock.callArgs = []*ServiceMockDeleteDeviceParams{}

	m.GetDeviceMock = mServiceMockGetDevice{mock: m}
	m.GetDeviceMock.callArgs = []*ServiceMockGetDeviceParams{}

	m.UpdateDeviceMock = mServiceMockUpdateDevice{mock: m}
	m.UpdateDeviceMock.callArgs = []*ServiceMockUpdateDeviceParams{}

	return m
}

type mServiceMockCreateDevice struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockCreateDeviceExpectation
	expectations       []*ServiceMockCreateDeviceExpectation

	callArgs []*ServiceMockCreateDeviceParams
	mutex    sync.RWMutex
}

// ServiceMockCreateDeviceExpectation specifies expectation struct of the Service.CreateDevice
type ServiceMockCreateDeviceExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockCreateDeviceParams
	results *ServiceMockCreateDeviceResults
	Counter uint64
}

// ServiceMockCreateDeviceParams contains parameters of the Service.CreateDevice
type ServiceMockCreateDeviceParams struct {
	d1 model.Device
}

// ServiceMockCreateDeviceResults contains results of the Service.CreateDevice
type ServiceMockCreateDeviceResults struct {
	err error
}

// Expect sets up expected params for Service.CreateDevice
func (mmCreateDevice *mServiceMockCreateDevice) Expect(d1 model.Device) *mServiceMockCreateDevice {
	if mmCreateDevice.mock.funcCreateDevice != nil {
		mmCreateDevice.mock.t.Fatalf("ServiceMock.CreateDevice mock is already set by Set")
	}

	if mmCreateDevice.defaultExpectation == nil {
		mmCreateDevice.defaultExpectation = &ServiceMockCreateDeviceExpectation{}
	}

	mmCreateDevice.defaultExpectation.params = &ServiceMockCreateDeviceParams{d1}
	for _, e := range mmCreateDevice.expectations {
		if minimock.Equal(e.params, mmCreateDevice.defaultExpectation.params) {
			mmCreateDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateDevice.defaultExpectation.params)
		}
	}

	return mmCreateDevice
}

// Inspect accepts an inspector function that has same arguments as the Service.CreateDevice
func (mmCreateDevice *mServiceMockCreateDevice) Inspect(f func(d1 model.Device)) *mServiceMockCreateDevice {
	if mmCreateDevice.mock.inspectFuncCreateDevice != nil {
		mmCreateDevice.mock.t.Fatalf("Inspect function is already set for ServiceMock.CreateDevice")
	}

	mmCreateDevice.mock.inspectFuncCreateDevice = f

	return mmCreateDevice
}

// Return sets up results that will be returned by Service.CreateDevice
func (mmCreateDevice *mServiceMockCreateDevice) Return(err error) *ServiceMock {
	if mmCreateDevice.mock.funcCreateDevice != nil {
		mmCreateDevice.mock.t.Fatalf("ServiceMock.CreateDevice mock is already set by Set")
	}

	if mmCreateDevice.defaultExpectation == nil {
		mmCreateDevice.defaultExpectation = &ServiceMockCreateDeviceExpectation{mock: mmCreateDevice.mock}
	}
	mmCreateDevice.defaultExpectation.results = &ServiceMockCreateDeviceResults{err}
	return mmCreateDevice.mock
}

// Set uses given function f to mock the Service.CreateDevice method
func (mmCreateDevice *mServiceMockCreateDevice) Set(f func(d1 model.Device) (err error)) *ServiceMock {
	if mmCreateDevice.defaultExpectation != nil {
		mmCreateDevice.mock.t.Fatalf("Default expectation is already set for the Service.CreateDevice method")
	}

	if len(mmCreateDevice.expectations) > 0 {
		mmCreateDevice.mock.t.Fatalf("Some expectations are already set for the Service.CreateDevice method")
	}

	mmCreateDevice.mock.funcCreateDevice = f
	return mmCreateDevice.mock
}

// When sets expectation for the Service.CreateDevice which will trigger the result defined by the following
// Then helper
func (mmCreateDevice *mServiceMockCreateDevice) When(d1 model.Device) *ServiceMockCreateDeviceExpectation {
	if mmCreateDevice.mock.funcCreateDevice != nil {
		mmCreateDevice.mock.t.Fatalf("ServiceMock.CreateDevice mock is already set by Set")
	}

	expectation := &ServiceMockCreateDeviceExpectation{
		mock:   mmCreateDevice.mock,
		params: &ServiceMockCreateDeviceParams{d1},
	}
	mmCreateDevice.expectations = append(mmCreateDevice.expectations, expectation)
	return expectation
}

// Then sets up Service.CreateDevice return parameters for the expectation previously defined by the When method
func (e *ServiceMockCreateDeviceExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCreateDeviceResults{err}
	return e.mock
}

// CreateDevice implements Service
func (mmCreateDevice *ServiceMock) CreateDevice(d1 model.Device) (err error) {
	mm_atomic.AddUint64(&mmCreateDevice.beforeCreateDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateDevice.afterCreateDeviceCounter, 1)

	if mmCreateDevice.inspectFuncCreateDevice != nil {
		mmCreateDevice.inspectFuncCreateDevice(d1)
	}

	mm_params := &ServiceMockCreateDeviceParams{d1}

	// Record call args
	mmCreateDevice.CreateDeviceMock.mutex.Lock()
	mmCreateDevice.CreateDeviceMock.callArgs = append(mmCreateDevice.CreateDeviceMock.callArgs, mm_params)
	mmCreateDevice.CreateDeviceMock.mutex.Unlock()

	for _, e := range mmCreateDevice.CreateDeviceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateDevice.CreateDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateDevice.CreateDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateDevice.CreateDeviceMock.defaultExpectation.params
		mm_got := ServiceMockCreateDeviceParams{d1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateDevice.t.Errorf("ServiceMock.CreateDevice got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateDevice.CreateDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateDevice.t.Fatal("No results are set for the ServiceMock.CreateDevice")
		}
		return (*mm_results).err
	}
	if mmCreateDevice.funcCreateDevice != nil {
		return mmCreateDevice.funcCreateDevice(d1)
	}
	mmCreateDevice.t.Fatalf("Unexpected call to ServiceMock.CreateDevice. %v", d1)
	return
}

// CreateDeviceAfterCounter returns a count of finished ServiceMock.CreateDevice invocations
func (mmCreateDevice *ServiceMock) CreateDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateDevice.afterCreateDeviceCounter)
}

// CreateDeviceBeforeCounter returns a count of ServiceMock.CreateDevice invocations
func (mmCreateDevice *ServiceMock) CreateDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateDevice.beforeCreateDeviceCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CreateDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateDevice *mServiceMockCreateDevice) Calls() []*ServiceMockCreateDeviceParams {
	mmCreateDevice.mutex.RLock()

	argCopy := make([]*ServiceMockCreateDeviceParams, len(mmCreateDevice.callArgs))
	copy(argCopy, mmCreateDevice.callArgs)

	mmCreateDevice.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDeviceDone returns true if the count of the CreateDevice invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCreateDeviceDone() bool {
	for _, e := range m.CreateDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateDeviceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateDeviceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateDevice != nil && mm_atomic.LoadUint64(&m.afterCreateDeviceCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateDeviceInspect logs each unmet expectation
func (m *ServiceMock) MinimockCreateDeviceInspect() {
	for _, e := range m.CreateDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CreateDevice with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateDeviceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateDeviceCounter) < 1 {
		if m.CreateDeviceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.CreateDevice")
		} else {
			m.t.Errorf("Expected call to ServiceMock.CreateDevice with params: %#v", *m.CreateDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateDevice != nil && mm_atomic.LoadUint64(&m.afterCreateDeviceCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.CreateDevice")
	}
}

type mServiceMockDeleteDevice struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteDeviceExpectation
	expectations       []*ServiceMockDeleteDeviceExpectation

	callArgs []*ServiceMockDeleteDeviceParams
	mutex    sync.RWMutex
}

// ServiceMockDeleteDeviceExpectation specifies expectation struct of the Service.DeleteDevice
type ServiceMockDeleteDeviceExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockDeleteDeviceParams
	results *ServiceMockDeleteDeviceResults
	Counter uint64
}

// ServiceMockDeleteDeviceParams contains parameters of the Service.DeleteDevice
type ServiceMockDeleteDeviceParams struct {
	s1 string
}

// ServiceMockDeleteDeviceResults contains results of the Service.DeleteDevice
type ServiceMockDeleteDeviceResults struct {
	err error
}

// Expect sets up expected params for Service.DeleteDevice
func (mmDeleteDevice *mServiceMockDeleteDevice) Expect(s1 string) *mServiceMockDeleteDevice {
	if mmDeleteDevice.mock.funcDeleteDevice != nil {
		mmDeleteDevice.mock.t.Fatalf("ServiceMock.DeleteDevice mock is already set by Set")
	}

	if mmDeleteDevice.defaultExpectation == nil {
		mmDeleteDevice.defaultExpectation = &ServiceMockDeleteDeviceExpectation{}
	}

	mmDeleteDevice.defaultExpectation.params = &ServiceMockDeleteDeviceParams{s1}
	for _, e := range mmDeleteDevice.expectations {
		if minimock.Equal(e.params, mmDeleteDevice.defaultExpectation.params) {
			mmDeleteDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteDevice.defaultExpectation.params)
		}
	}

	return mmDeleteDevice
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteDevice
func (mmDeleteDevice *mServiceMockDeleteDevice) Inspect(f func(s1 string)) *mServiceMockDeleteDevice {
	if mmDeleteDevice.mock.inspectFuncDeleteDevice != nil {
		mmDeleteDevice.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteDevice")
	}

	mmDeleteDevice.mock.inspectFuncDeleteDevice = f

	return mmDeleteDevice
}

// Return sets up results that will be returned by Service.DeleteDevice
func (mmDeleteDevice *mServiceMockDeleteDevice) Return(err error) *ServiceMock {
	if mmDeleteDevice.mock.funcDeleteDevice != nil {
		mmDeleteDevice.mock.t.Fatalf("ServiceMock.DeleteDevice mock is already set by Set")
	}

	if mmDeleteDevice.defaultExpectation == nil {
		mmDeleteDevice.defaultExpectation = &ServiceMockDeleteDeviceExpectation{mock: mmDeleteDevice.mock}
	}
	mmDeleteDevice.defaultExpectation.results = &ServiceMockDeleteDeviceResults{err}
	return mmDeleteDevice.mock
}

// Set uses given function f to mock the Service.DeleteDevice method
func (mmDeleteDevice *mServiceMockDeleteDevice) Set(f func(s1 string) (err error)) *ServiceMock {
	if mmDeleteDevice.defaultExpectation != nil {
		mmDeleteDevice.mock.t.Fatalf("Default expectation is already set for the Service.DeleteDevice method")
	}

	if len(mmDeleteDevice.expectations) > 0 {
		mmDeleteDevice.mock.t.Fatalf("Some expectations are already set for the Service.DeleteDevice method")
	}

	mmDeleteDevice.mock.funcDeleteDevice = f
	return mmDeleteDevice.mock
}

// When sets expectation for the Service.DeleteDevice which will trigger the result defined by the following
// Then helper
func (mmDeleteDevice *mServiceMockDeleteDevice) When(s1 string) *ServiceMockDeleteDeviceExpectation {
	if mmDeleteDevice.mock.funcDeleteDevice != nil {
		mmDeleteDevice.mock.t.Fatalf("ServiceMock.DeleteDevice mock is already set by Set")
	}

	expectation := &ServiceMockDeleteDeviceExpectation{
		mock:   mmDeleteDevice.mock,
		params: &ServiceMockDeleteDeviceParams{s1},
	}
	mmDeleteDevice.expectations = append(mmDeleteDevice.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteDevice return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteDeviceExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteDeviceResults{err}
	return e.mock
}

// DeleteDevice implements Service
func (mmDeleteDevice *ServiceMock) DeleteDevice(s1 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteDevice.beforeDeleteDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteDevice.afterDeleteDeviceCounter, 1)

	if mmDeleteDevice.inspectFuncDeleteDevice != nil {
		mmDeleteDevice.inspectFuncDeleteDevice(s1)
	}

	mm_params := &ServiceMockDeleteDeviceParams{s1}

	// Record call args
	mmDeleteDevice.DeleteDeviceMock.mutex.Lock()
	mmDeleteDevice.DeleteDeviceMock.callArgs = append(mmDeleteDevice.DeleteDeviceMock.callArgs, mm_params)
	mmDeleteDevice.DeleteDeviceMock.mutex.Unlock()

	for _, e := range mmDeleteDevice.DeleteDeviceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteDevice.DeleteDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteDevice.DeleteDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteDevice.DeleteDeviceMock.defaultExpectation.params
		mm_got := ServiceMockDeleteDeviceParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteDevice.t.Errorf("ServiceMock.DeleteDevice got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteDevice.DeleteDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteDevice.t.Fatal("No results are set for the ServiceMock.DeleteDevice")
		}
		return (*mm_results).err
	}
	if mmDeleteDevice.funcDeleteDevice != nil {
		return mmDeleteDevice.funcDeleteDevice(s1)
	}
	mmDeleteDevice.t.Fatalf("Unexpected call to ServiceMock.DeleteDevice. %v", s1)
	return
}

// DeleteDeviceAfterCounter returns a count of finished ServiceMock.DeleteDevice invocations
func (mmDeleteDevice *ServiceMock) DeleteDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteDevice.afterDeleteDeviceCounter)
}

// DeleteDeviceBeforeCounter returns a count of ServiceMock.DeleteDevice invocations
func (mmDeleteDevice *ServiceMock) DeleteDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteDevice.beforeDeleteDeviceCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteDevice *mServiceMockDeleteDevice) Calls() []*ServiceMockDeleteDeviceParams {
	mmDeleteDevice.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteDeviceParams, len(mmDeleteDevice.callArgs))
	copy(argCopy, mmDeleteDevice.callArgs)

	mmDeleteDevice.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDeviceDone returns true if the count of the DeleteDevice invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteDeviceDone() bool {
	for _, e := range m.DeleteDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteDeviceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteDeviceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteDevice != nil && mm_atomic.LoadUint64(&m.afterDeleteDeviceCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteDeviceInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteDeviceInspect() {
	for _, e := range m.DeleteDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteDevice with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteDeviceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteDeviceCounter) < 1 {
		if m.DeleteDeviceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.DeleteDevice")
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteDevice with params: %#v", *m.DeleteDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteDevice != nil && mm_atomic.LoadUint64(&m.afterDeleteDeviceCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.DeleteDevice")
	}
}

type mServiceMockGetDevice struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetDeviceExpectation
	expectations       []*ServiceMockGetDeviceExpectation

	callArgs []*ServiceMockGetDeviceParams
	mutex    sync.RWMutex
}

// ServiceMockGetDeviceExpectation specifies expectation struct of the Service.GetDevice
type ServiceMockGetDeviceExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockGetDeviceParams
	results *ServiceMockGetDeviceResults
	Counter uint64
}

// ServiceMockGetDeviceParams contains parameters of the Service.GetDevice
type ServiceMockGetDeviceParams struct {
	s1 string
}

// ServiceMockGetDeviceResults contains results of the Service.GetDevice
type ServiceMockGetDeviceResults struct {
	d1  model.Device
	err error
}

// Expect sets up expected params for Service.GetDevice
func (mmGetDevice *mServiceMockGetDevice) Expect(s1 string) *mServiceMockGetDevice {
	if mmGetDevice.mock.funcGetDevice != nil {
		mmGetDevice.mock.t.Fatalf("ServiceMock.GetDevice mock is already set by Set")
	}

	if mmGetDevice.defaultExpectation == nil {
		mmGetDevice.defaultExpectation = &ServiceMockGetDeviceExpectation{}
	}

	mmGetDevice.defaultExpectation.params = &ServiceMockGetDeviceParams{s1}
	for _, e := range mmGetDevice.expectations {
		if minimock.Equal(e.params, mmGetDevice.defaultExpectation.params) {
			mmGetDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDevice.defaultExpectation.params)
		}
	}

	return mmGetDevice
}

// Inspect accepts an inspector function that has same arguments as the Service.GetDevice
func (mmGetDevice *mServiceMockGetDevice) Inspect(f func(s1 string)) *mServiceMockGetDevice {
	if mmGetDevice.mock.inspectFuncGetDevice != nil {
		mmGetDevice.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetDevice")
	}

	mmGetDevice.mock.inspectFuncGetDevice = f

	return mmGetDevice
}

// Return sets up results that will be returned by Service.GetDevice
func (mmGetDevice *mServiceMockGetDevice) Return(d1 model.Device, err error) *ServiceMock {
	if mmGetDevice.mock.funcGetDevice != nil {
		mmGetDevice.mock.t.Fatalf("ServiceMock.GetDevice mock is already set by Set")
	}

	if mmGetDevice.defaultExpectation == nil {
		mmGetDevice.defaultExpectation = &ServiceMockGetDeviceExpectation{mock: mmGetDevice.mock}
	}
	mmGetDevice.defaultExpectation.results = &ServiceMockGetDeviceResults{d1, err}
	return mmGetDevice.mock
}

// Set uses given function f to mock the Service.GetDevice method
func (mmGetDevice *mServiceMockGetDevice) Set(f func(s1 string) (d1 model.Device, err error)) *ServiceMock {
	if mmGetDevice.defaultExpectation != nil {
		mmGetDevice.mock.t.Fatalf("Default expectation is already set for the Service.GetDevice method")
	}

	if len(mmGetDevice.expectations) > 0 {
		mmGetDevice.mock.t.Fatalf("Some expectations are already set for the Service.GetDevice method")
	}

	mmGetDevice.mock.funcGetDevice = f
	return mmGetDevice.mock
}

// When sets expectation for the Service.GetDevice which will trigger the result defined by the following
// Then helper
func (mmGetDevice *mServiceMockGetDevice) When(s1 string) *ServiceMockGetDeviceExpectation {
	if mmGetDevice.mock.funcGetDevice != nil {
		mmGetDevice.mock.t.Fatalf("ServiceMock.GetDevice mock is already set by Set")
	}

	expectation := &ServiceMockGetDeviceExpectation{
		mock:   mmGetDevice.mock,
		params: &ServiceMockGetDeviceParams{s1},
	}
	mmGetDevice.expectations = append(mmGetDevice.expectations, expectation)
	return expectation
}

// Then sets up Service.GetDevice return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetDeviceExpectation) Then(d1 model.Device, err error) *ServiceMock {
	e.results = &ServiceMockGetDeviceResults{d1, err}
	return e.mock
}

// GetDevice implements Service
func (mmGetDevice *ServiceMock) GetDevice(s1 string) (d1 model.Device, err error) {
	mm_atomic.AddUint64(&mmGetDevice.beforeGetDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDevice.afterGetDeviceCounter, 1)

	if mmGetDevice.inspectFuncGetDevice != nil {
		mmGetDevice.inspectFuncGetDevice(s1)
	}

	mm_params := &ServiceMockGetDeviceParams{s1}

	// Record call args
	mmGetDevice.GetDeviceMock.mutex.Lock()
	mmGetDevice.GetDeviceMock.callArgs = append(mmGetDevice.GetDeviceMock.callArgs, mm_params)
	mmGetDevice.GetDeviceMock.mutex.Unlock()

	for _, e := range mmGetDevice.GetDeviceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.err
		}
	}

	if mmGetDevice.GetDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDevice.GetDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDevice.GetDeviceMock.defaultExpectation.params
		mm_got := ServiceMockGetDeviceParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDevice.t.Errorf("ServiceMock.GetDevice got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDevice.GetDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDevice.t.Fatal("No results are set for the ServiceMock.GetDevice")
		}
		return (*mm_results).d1, (*mm_results).err
	}
	if mmGetDevice.funcGetDevice != nil {
		return mmGetDevice.funcGetDevice(s1)
	}
	mmGetDevice.t.Fatalf("Unexpected call to ServiceMock.GetDevice. %v", s1)
	return
}

// GetDeviceAfterCounter returns a count of finished ServiceMock.GetDevice invocations
func (mmGetDevice *ServiceMock) GetDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDevice.afterGetDeviceCounter)
}

// GetDeviceBeforeCounter returns a count of ServiceMock.GetDevice invocations
func (mmGetDevice *ServiceMock) GetDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDevice.beforeGetDeviceCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDevice *mServiceMockGetDevice) Calls() []*ServiceMockGetDeviceParams {
	mmGetDevice.mutex.RLock()

	argCopy := make([]*ServiceMockGetDeviceParams, len(mmGetDevice.callArgs))
	copy(argCopy, mmGetDevice.callArgs)

	mmGetDevice.mutex.RUnlock()

	return argCopy
}

// MinimockGetDeviceDone returns true if the count of the GetDevice invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetDeviceDone() bool {
	for _, e := range m.GetDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDeviceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDeviceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDevice != nil && mm_atomic.LoadUint64(&m.afterGetDeviceCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDeviceInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetDeviceInspect() {
	for _, e := range m.GetDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetDevice with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDeviceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDeviceCounter) < 1 {
		if m.GetDeviceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.GetDevice")
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetDevice with params: %#v", *m.GetDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDevice != nil && mm_atomic.LoadUint64(&m.afterGetDeviceCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.GetDevice")
	}
}

type mServiceMockUpdateDevice struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockUpdateDeviceExpectation
	expectations       []*ServiceMockUpdateDeviceExpectation

	callArgs []*ServiceMockUpdateDeviceParams
	mutex    sync.RWMutex
}

// ServiceMockUpdateDeviceExpectation specifies expectation struct of the Service.UpdateDevice
type ServiceMockUpdateDeviceExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockUpdateDeviceParams
	results *ServiceMockUpdateDeviceResults
	Counter uint64
}

// ServiceMockUpdateDeviceParams contains parameters of the Service.UpdateDevice
type ServiceMockUpdateDeviceParams struct {
	d1 model.Device
}

// ServiceMockUpdateDeviceResults contains results of the Service.UpdateDevice
type ServiceMockUpdateDeviceResults struct {
	err error
}

// Expect sets up expected params for Service.UpdateDevice
func (mmUpdateDevice *mServiceMockUpdateDevice) Expect(d1 model.Device) *mServiceMockUpdateDevice {
	if mmUpdateDevice.mock.funcUpdateDevice != nil {
		mmUpdateDevice.mock.t.Fatalf("ServiceMock.UpdateDevice mock is already set by Set")
	}

	if mmUpdateDevice.defaultExpectation == nil {
		mmUpdateDevice.defaultExpectation = &ServiceMockUpdateDeviceExpectation{}
	}

	mmUpdateDevice.defaultExpectation.params = &ServiceMockUpdateDeviceParams{d1}
	for _, e := range mmUpdateDevice.expectations {
		if minimock.Equal(e.params, mmUpdateDevice.defaultExpectation.params) {
			mmUpdateDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateDevice.defaultExpectation.params)
		}
	}

	return mmUpdateDevice
}

// Inspect accepts an inspector function that has same arguments as the Service.UpdateDevice
func (mmUpdateDevice *mServiceMockUpdateDevice) Inspect(f func(d1 model.Device)) *mServiceMockUpdateDevice {
	if mmUpdateDevice.mock.inspectFuncUpdateDevice != nil {
		mmUpdateDevice.mock.t.Fatalf("Inspect function is already set for ServiceMock.UpdateDevice")
	}

	mmUpdateDevice.mock.inspectFuncUpdateDevice = f

	return mmUpdateDevice
}

// Return sets up results that will be returned by Service.UpdateDevice
func (mmUpdateDevice *mServiceMockUpdateDevice) Return(err error) *ServiceMock {
	if mmUpdateDevice.mock.funcUpdateDevice != nil {
		mmUpdateDevice.mock.t.Fatalf("ServiceMock.UpdateDevice mock is already set by Set")
	}

	if mmUpdateDevice.defaultExpectation == nil {
		mmUpdateDevice.defaultExpectation = &ServiceMockUpdateDeviceExpectation{mock: mmUpdateDevice.mock}
	}
	mmUpdateDevice.defaultExpectation.results = &ServiceMockUpdateDeviceResults{err}
	return mmUpdateDevice.mock
}

// Set uses given function f to mock the Service.UpdateDevice method
func (mmUpdateDevice *mServiceMockUpdateDevice) Set(f func(d1 model.Device) (err error)) *ServiceMock {
	if mmUpdateDevice.defaultExpectation != nil {
		mmUpdateDevice.mock.t.Fatalf("Default expectation is already set for the Service.UpdateDevice method")
	}

	if len(mmUpdateDevice.expectations) > 0 {
		mmUpdateDevice.mock.t.Fatalf("Some expectations are already set for the Service.UpdateDevice method")
	}

	mmUpdateDevice.mock.funcUpdateDevice = f
	return mmUpdateDevice.mock
}

// When sets expectation for the Service.UpdateDevice which will trigger the result defined by the following
// Then helper
func (mmUpdateDevice *mServiceMockUpdateDevice) When(d1 model.Device) *ServiceMockUpdateDeviceExpectation {
	if mmUpdateDevice.mock.funcUpdateDevice != nil {
		mmUpdateDevice.mock.t.Fatalf("ServiceMock.UpdateDevice mock is already set by Set")
	}

	expectation := &ServiceMockUpdateDeviceExpectation{
		mock:   mmUpdateDevice.mock,
		params: &ServiceMockUpdateDeviceParams{d1},
	}
	mmUpdateDevice.expectations = append(mmUpdateDevice.expectations, expectation)
	return expectation
}

// Then sets up Service.UpdateDevice return parameters for the expectation previously defined by the When method
func (e *ServiceMockUpdateDeviceExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockUpdateDeviceResults{err}
	return e.mock
}

// UpdateDevice implements Service
func (mmUpdateDevice *ServiceMock) UpdateDevice(d1 model.Device) (err error) {
	mm_atomic.AddUint64(&mmUpdateDevice.beforeUpdateDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateDevice.afterUpdateDeviceCounter, 1)

	if mmUpdateDevice.inspectFuncUpdateDevice != nil {
		mmUpdateDevice.inspectFuncUpdateDevice(d1)
	}

	mm_params := &ServiceMockUpdateDeviceParams{d1}

	// Record call args
	mmUpdateDevice.UpdateDeviceMock.mutex.Lock()
	mmUpdateDevice.UpdateDeviceMock.callArgs = append(mmUpdateDevice.UpdateDeviceMock.callArgs, mm_params)
	mmUpdateDevice.UpdateDeviceMock.mutex.Unlock()

	for _, e := range mmUpdateDevice.UpdateDeviceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateDevice.UpdateDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateDevice.UpdateDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateDevice.UpdateDeviceMock.defaultExpectation.params
		mm_got := ServiceMockUpdateDeviceParams{d1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateDevice.t.Errorf("ServiceMock.UpdateDevice got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateDevice.UpdateDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateDevice.t.Fatal("No results are set for the ServiceMock.UpdateDevice")
		}
		return (*mm_results).err
	}
	if mmUpdateDevice.funcUpdateDevice != nil {
		return mmUpdateDevice.funcUpdateDevice(d1)
	}
	mmUpdateDevice.t.Fatalf("Unexpected call to ServiceMock.UpdateDevice. %v", d1)
	return
}

// UpdateDeviceAfterCounter returns a count of finished ServiceMock.UpdateDevice invocations
func (mmUpdateDevice *ServiceMock) UpdateDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDevice.afterUpdateDeviceCounter)
}

// UpdateDeviceBeforeCounter returns a count of ServiceMock.UpdateDevice invocations
func (mmUpdateDevice *ServiceMock) UpdateDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDevice.beforeUpdateDeviceCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.UpdateDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateDevice *mServiceMockUpdateDevice) Calls() []*ServiceMockUpdateDeviceParams {
	mmUpdateDevice.mutex.RLock()

	argCopy := make([]*ServiceMockUpdateDeviceParams, len(mmUpdateDevice.callArgs))
	copy(argCopy, mmUpdateDevice.callArgs)

	mmUpdateDevice.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDeviceDone returns true if the count of the UpdateDevice invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockUpdateDeviceDone() bool {
	for _, e := range m.UpdateDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateDeviceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateDeviceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateDevice != nil && mm_atomic.LoadUint64(&m.afterUpdateDeviceCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateDeviceInspect logs each unmet expectation
func (m *ServiceMock) MinimockUpdateDeviceInspect() {
	for _, e := range m.UpdateDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.UpdateDevice with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateDeviceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateDeviceCounter) < 1 {
		if m.UpdateDeviceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.UpdateDevice")
		} else {
			m.t.Errorf("Expected call to ServiceMock.UpdateDevice with params: %#v", *m.UpdateDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateDevice != nil && mm_atomic.LoadUint64(&m.afterUpdateDeviceCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.UpdateDevice")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateDeviceInspect()

		m.MinimockDeleteDeviceInspect()

		m.MinimockGetDeviceInspect()

		m.MinimockUpdateDeviceInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDeviceDone() &&
		m.MinimockDeleteDeviceDone() &&
		m.MinimockGetDeviceDone() &&
		m.MinimockUpdateDeviceDone()
}
