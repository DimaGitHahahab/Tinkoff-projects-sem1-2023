package service

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i homework/internal/service.Storage -o ./storage_mock_test.go -n StorageMock

import (
	"homework/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorageMock implements Storage
type StorageMock struct {
	t minimock.Tester

	funcAdd          func(d model.Device) (b1 bool)
	inspectFuncAdd   func(d model.Device)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mStorageMockAdd

	funcDel          func(num string) (b1 bool)
	inspectFuncDel   func(num string)
	afterDelCounter  uint64
	beforeDelCounter uint64
	DelMock          mStorageMockDel

	funcGet          func(num string) (d1 model.Device, b1 bool)
	inspectFuncGet   func(num string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mStorageMockGet
}

// NewStorageMock returns a mock for Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mStorageMockAdd{mock: m}
	m.AddMock.callArgs = []*StorageMockAddParams{}

	m.DelMock = mStorageMockDel{mock: m}
	m.DelMock.callArgs = []*StorageMockDelParams{}

	m.GetMock = mStorageMockGet{mock: m}
	m.GetMock.callArgs = []*StorageMockGetParams{}

	return m
}

type mStorageMockAdd struct {
	mock               *StorageMock
	defaultExpectation *StorageMockAddExpectation
	expectations       []*StorageMockAddExpectation

	callArgs []*StorageMockAddParams
	mutex    sync.RWMutex
}

// StorageMockAddExpectation specifies expectation struct of the Storage.Add
type StorageMockAddExpectation struct {
	mock    *StorageMock
	params  *StorageMockAddParams
	results *StorageMockAddResults
	Counter uint64
}

// StorageMockAddParams contains parameters of the Storage.Add
type StorageMockAddParams struct {
	d model.Device
}

// StorageMockAddResults contains results of the Storage.Add
type StorageMockAddResults struct {
	b1 bool
}

// Expect sets up expected params for Storage.Add
func (mmAdd *mStorageMockAdd) Expect(d model.Device) *mStorageMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("StorageMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &StorageMockAddExpectation{}
	}

	mmAdd.defaultExpectation.params = &StorageMockAddParams{d}
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the Storage.Add
func (mmAdd *mStorageMockAdd) Inspect(f func(d model.Device)) *mStorageMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for StorageMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by Storage.Add
func (mmAdd *mStorageMockAdd) Return(b1 bool) *StorageMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("StorageMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &StorageMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &StorageMockAddResults{b1}
	return mmAdd.mock
}

// Set uses given function f to mock the Storage.Add method
func (mmAdd *mStorageMockAdd) Set(f func(d model.Device) (b1 bool)) *StorageMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the Storage.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the Storage.Add method")
	}

	mmAdd.mock.funcAdd = f
	return mmAdd.mock
}

// When sets expectation for the Storage.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mStorageMockAdd) When(d model.Device) *StorageMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("StorageMock.Add mock is already set by Set")
	}

	expectation := &StorageMockAddExpectation{
		mock:   mmAdd.mock,
		params: &StorageMockAddParams{d},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up Storage.Add return parameters for the expectation previously defined by the When method
func (e *StorageMockAddExpectation) Then(b1 bool) *StorageMock {
	e.results = &StorageMockAddResults{b1}
	return e.mock
}

// Add implements Storage
func (mmAdd *StorageMock) Add(d model.Device) (b1 bool) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(d)
	}

	mm_params := &StorageMockAddParams{d}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_got := StorageMockAddParams{d}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("StorageMock.Add got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the StorageMock.Add")
		}
		return (*mm_results).b1
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(d)
	}
	mmAdd.t.Fatalf("Unexpected call to StorageMock.Add. %v", d)
	return
}

// AddAfterCounter returns a count of finished StorageMock.Add invocations
func (mmAdd *StorageMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of StorageMock.Add invocations
func (mmAdd *StorageMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mStorageMockAdd) Calls() []*StorageMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*StorageMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockAddDone() bool {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddInspect logs each unmet expectation
func (m *StorageMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Add with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Add")
		} else {
			m.t.Errorf("Expected call to StorageMock.Add with params: %#v", *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Add")
	}
}

type mStorageMockDel struct {
	mock               *StorageMock
	defaultExpectation *StorageMockDelExpectation
	expectations       []*StorageMockDelExpectation

	callArgs []*StorageMockDelParams
	mutex    sync.RWMutex
}

// StorageMockDelExpectation specifies expectation struct of the Storage.Del
type StorageMockDelExpectation struct {
	mock    *StorageMock
	params  *StorageMockDelParams
	results *StorageMockDelResults
	Counter uint64
}

// StorageMockDelParams contains parameters of the Storage.Del
type StorageMockDelParams struct {
	num string
}

// StorageMockDelResults contains results of the Storage.Del
type StorageMockDelResults struct {
	b1 bool
}

// Expect sets up expected params for Storage.Del
func (mmDel *mStorageMockDel) Expect(num string) *mStorageMockDel {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("StorageMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &StorageMockDelExpectation{}
	}

	mmDel.defaultExpectation.params = &StorageMockDelParams{num}
	for _, e := range mmDel.expectations {
		if minimock.Equal(e.params, mmDel.defaultExpectation.params) {
			mmDel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDel.defaultExpectation.params)
		}
	}

	return mmDel
}

// Inspect accepts an inspector function that has same arguments as the Storage.Del
func (mmDel *mStorageMockDel) Inspect(f func(num string)) *mStorageMockDel {
	if mmDel.mock.inspectFuncDel != nil {
		mmDel.mock.t.Fatalf("Inspect function is already set for StorageMock.Del")
	}

	mmDel.mock.inspectFuncDel = f

	return mmDel
}

// Return sets up results that will be returned by Storage.Del
func (mmDel *mStorageMockDel) Return(b1 bool) *StorageMock {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("StorageMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &StorageMockDelExpectation{mock: mmDel.mock}
	}
	mmDel.defaultExpectation.results = &StorageMockDelResults{b1}
	return mmDel.mock
}

// Set uses given function f to mock the Storage.Del method
func (mmDel *mStorageMockDel) Set(f func(num string) (b1 bool)) *StorageMock {
	if mmDel.defaultExpectation != nil {
		mmDel.mock.t.Fatalf("Default expectation is already set for the Storage.Del method")
	}

	if len(mmDel.expectations) > 0 {
		mmDel.mock.t.Fatalf("Some expectations are already set for the Storage.Del method")
	}

	mmDel.mock.funcDel = f
	return mmDel.mock
}

// When sets expectation for the Storage.Del which will trigger the result defined by the following
// Then helper
func (mmDel *mStorageMockDel) When(num string) *StorageMockDelExpectation {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("StorageMock.Del mock is already set by Set")
	}

	expectation := &StorageMockDelExpectation{
		mock:   mmDel.mock,
		params: &StorageMockDelParams{num},
	}
	mmDel.expectations = append(mmDel.expectations, expectation)
	return expectation
}

// Then sets up Storage.Del return parameters for the expectation previously defined by the When method
func (e *StorageMockDelExpectation) Then(b1 bool) *StorageMock {
	e.results = &StorageMockDelResults{b1}
	return e.mock
}

// Del implements Storage
func (mmDel *StorageMock) Del(num string) (b1 bool) {
	mm_atomic.AddUint64(&mmDel.beforeDelCounter, 1)
	defer mm_atomic.AddUint64(&mmDel.afterDelCounter, 1)

	if mmDel.inspectFuncDel != nil {
		mmDel.inspectFuncDel(num)
	}

	mm_params := &StorageMockDelParams{num}

	// Record call args
	mmDel.DelMock.mutex.Lock()
	mmDel.DelMock.callArgs = append(mmDel.DelMock.callArgs, mm_params)
	mmDel.DelMock.mutex.Unlock()

	for _, e := range mmDel.DelMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmDel.DelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDel.DelMock.defaultExpectation.Counter, 1)
		mm_want := mmDel.DelMock.defaultExpectation.params
		mm_got := StorageMockDelParams{num}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDel.t.Errorf("StorageMock.Del got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDel.DelMock.defaultExpectation.results
		if mm_results == nil {
			mmDel.t.Fatal("No results are set for the StorageMock.Del")
		}
		return (*mm_results).b1
	}
	if mmDel.funcDel != nil {
		return mmDel.funcDel(num)
	}
	mmDel.t.Fatalf("Unexpected call to StorageMock.Del. %v", num)
	return
}

// DelAfterCounter returns a count of finished StorageMock.Del invocations
func (mmDel *StorageMock) DelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDel.afterDelCounter)
}

// DelBeforeCounter returns a count of StorageMock.Del invocations
func (mmDel *StorageMock) DelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDel.beforeDelCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Del.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDel *mStorageMockDel) Calls() []*StorageMockDelParams {
	mmDel.mutex.RLock()

	argCopy := make([]*StorageMockDelParams, len(mmDel.callArgs))
	copy(argCopy, mmDel.callArgs)

	mmDel.mutex.RUnlock()

	return argCopy
}

// MinimockDelDone returns true if the count of the Del invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockDelDone() bool {
	for _, e := range m.DelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDel != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		return false
	}
	return true
}

// MinimockDelInspect logs each unmet expectation
func (m *StorageMock) MinimockDelInspect() {
	for _, e := range m.DelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Del with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		if m.DelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Del")
		} else {
			m.t.Errorf("Expected call to StorageMock.Del with params: %#v", *m.DelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDel != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Del")
	}
}

type mStorageMockGet struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetExpectation
	expectations       []*StorageMockGetExpectation

	callArgs []*StorageMockGetParams
	mutex    sync.RWMutex
}

// StorageMockGetExpectation specifies expectation struct of the Storage.Get
type StorageMockGetExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetParams
	results *StorageMockGetResults
	Counter uint64
}

// StorageMockGetParams contains parameters of the Storage.Get
type StorageMockGetParams struct {
	num string
}

// StorageMockGetResults contains results of the Storage.Get
type StorageMockGetResults struct {
	d1 model.Device
	b1 bool
}

// Expect sets up expected params for Storage.Get
func (mmGet *mStorageMockGet) Expect(num string) *mStorageMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("StorageMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &StorageMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &StorageMockGetParams{num}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Storage.Get
func (mmGet *mStorageMockGet) Inspect(f func(num string)) *mStorageMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for StorageMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Storage.Get
func (mmGet *mStorageMockGet) Return(d1 model.Device, b1 bool) *StorageMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("StorageMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &StorageMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &StorageMockGetResults{d1, b1}
	return mmGet.mock
}

// Set uses given function f to mock the Storage.Get method
func (mmGet *mStorageMockGet) Set(f func(num string) (d1 model.Device, b1 bool)) *StorageMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Storage.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Storage.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Storage.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mStorageMockGet) When(num string) *StorageMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("StorageMock.Get mock is already set by Set")
	}

	expectation := &StorageMockGetExpectation{
		mock:   mmGet.mock,
		params: &StorageMockGetParams{num},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Storage.Get return parameters for the expectation previously defined by the When method
func (e *StorageMockGetExpectation) Then(d1 model.Device, b1 bool) *StorageMock {
	e.results = &StorageMockGetResults{d1, b1}
	return e.mock
}

// Get implements Storage
func (mmGet *StorageMock) Get(num string) (d1 model.Device, b1 bool) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(num)
	}

	mm_params := &StorageMockGetParams{num}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.b1
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := StorageMockGetParams{num}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("StorageMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the StorageMock.Get")
		}
		return (*mm_results).d1, (*mm_results).b1
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(num)
	}
	mmGet.t.Fatalf("Unexpected call to StorageMock.Get. %v", num)
	return
}

// GetAfterCounter returns a count of finished StorageMock.Get invocations
func (mmGet *StorageMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of StorageMock.Get invocations
func (mmGet *StorageMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mStorageMockGet) Calls() []*StorageMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*StorageMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *StorageMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Get")
		} else {
			m.t.Errorf("Expected call to StorageMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Get")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddInspect()

		m.MinimockDelInspect()

		m.MinimockGetInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockDelDone() &&
		m.MinimockGetDone()
}
